import logging
import os
from enum import Enum

import django
from django.conf import settings  # NOQA

os.environ['DJANGO_SETTINGS_MODULE'] = 'api.config.settings'
django.setup()

# Get an instance of a logger
logger = logging.getLogger(__name__)


class TimeFrames(Enum):
    """
    Timeframe parameters.

    Options for timeframe parameter for getting bar data from TradeView api.
    """
    ONE_MIN = '1Min'
    FIVE_MIN = '5Min'
    FIFTEEN_MIN = '15Min'
    ONE_DAY = '1D'


# class TradeApiWebsocket:
#     """Base wrapper for TradeView API web socket."""

#     def __init__(self):
#         # TO DO

#     def __enter__(self):
#         # TO DO

#     def __exit__(self, exc_type, exc_val, exc_tb):
#         # TO DO

class TradeApiRest:
    """Base wrapper for TradeView REST requests."""

    def __init__(self):
        try:
            self.api = tradeapi.REST()
        except Exception as exc:
            logger.error(f'Tradeview api connection failed: {exc}')
            return

    def _account_info(self):
        """Retrieves account information."""
        return self.api.get_account()

    def _list_assets(self, status=None, asset_class=None):
        """
        Get master list of assets available for trade and data consumption from Alpaca.

        Params:
            - status(str): e.g. “active”. By default, all statuses are included
            - asset_class(str): Defaults to us_equity
        """
        return self.api.list_assets(status, asset_class)

    def _get_asset(self, symbol):
        """Get an asset for the given symbol."""
        return self.api.get_asset(symbol)

    def _list_positions(self):
        """Retrieves a list of the account’s open positions."""
        return self.api.list_positions()

    def _list_position_by_symbol(self, symbol):
        """Retrieves the account’s open position for the given symbol."""
        return self.api.get_position(symbol)

    def _get_orders(self, status=None, limit=None, after=None, until=None,
                    direction=None, nested=None):
        """
        Get order information.

        Params:
            - status(str): open, closed or all. Defaults to open
            - limit(int): max number of orders in response. Default 50, max 500
            - after(timestamp): response will include only ones submitted after this timestamp (exclusive.)
            - until(timestamp): response will include only ones submitted until this timestamp (exclusive.)
            - direction(str): order of response based on submission time. asc or desc. Defaults to desc.
            - nested(boolean): if true, the result will roll up multi-leg orders under the legs field of primary order.
        """
        return self.api.list_orders(status, limit, after, until, direction, nested)

    def _get_order_by_client_order_id(self, client_order_id):
        """"
        Get order details when client_order_id is manually speicified by client.
        """
        return self.api.get_order_by_client_order_id(client_order_id)

    def _get_order_by_id(self, order_id):
        """Get order details when id auto generated by Alpaca."""
        return self.api.get_order(order_id)

    def _cancel_order_by_id(self, order_id):
        """Closes (liquidates) the account’s open position for the given symbol. Works for both long and short positions."""
        return self.api.cancel_order(order_id)

    def _cancel_all_orders(self):
        """Closes (liquidates) all of the account’s open long and short positions."""
        return self.api.cancel_all_orders()

    def _submit_order(self, symbol, qty, side, type, time_in_force,
                      limit_price=None, stop_price=None, client_order_id=None,
                      order_class=None, take_profit=None, stop_loss=None,
                      trail_price=None, trail_percent=None):
        """
        Submit an order.

        Params:
            - symbol(str): symbol or asset ID to identify the asset to trade
            - qty(float): number of shares to trade
            - side(str): buy or sell
            - type(str): market, limit, stop, stop_limit, or trailing_stop
            - time_in_force(str):
                - day: a day order is eligible for execution only on the day it is live
                - gtc: good til cancelled
                - opg: use with a market/limit order type to submit 'market on open' (MOO) and 'limit on open' (LOO) orders
                - cls: use with a market/limit order type to submit 'market on close' (MOC) and 'limit on close' (LOC) orders
                - ioc: immediate or cancel requires all or part of the order to be executed immediately. Any unfilled portion
                    of the order is canceled (v2 API only)
                - fok: fill or kill is only executed if the entire order quantity can be filled, otherwise the order is
                    canceled (v2 API only)
            - limit_price(float): required if type is 'limit' or 'stop_limit'
            - stop_price(float): required if type is 'stop' or 'stop_limit'
            - tail_price(float): this or 'trail_percent' is required if type is 'trailing_stop'
            - tail_percentage(float): this or 'trail_price' is required if type is 'trailing_stop'
            - extended_hours(boolean): defaults false. If true, order will be eligible to execute
                in premarket/afterhours. Only works with type limit and time_in_force day
            - client_order_id(str): unique identifier for the order. Automatically generated if not sent.
            - order_class(str): simple, bracket, oco or oto
            - take_profit(dict):
                - limit_price(float): required for bracket orders
            - stop_loss(dict):
                - stop_limit(float): required for bracket orders
                - limit_price(float): the stop-loss order becomes a stop-limit order if specified

        """
        return self.api.submit_order(
            symbol, qty, side, type, time_in_force, limit_price, stop_price,
            client_order_id, order_class, take_profit, stop_loss, trail_price,
            trail_percent
        )

    def _daily_balance(self):
        account = self._account_info()
        return float(account.equity) - float(account.last_equity)

    def _is_tradable(self, symbol):
        """Is an asset tradable via Alpaca api."""
        if not isinstance(symbol, str):
            symbol = str(symbol)
        return self.api.get_asset(symbol).tradable

    def _is_market_open(self):
        """Return true if the market is currently open."""
        return self.api.get_clock().is_open

    def _open_orders(self):
        return self.api.list_orders(status='open')

    def _cancel_orders(self, id):
        return self.api.cancel_order(id)

    def _get_bars(self, symbols, limit, start, end, after, until):
        """
        Retrievs list of bars for each requested symbol.

        Params:
            - symbols: One or more (max 200) symbol names split by commas (",")
            - limit: The maximum number of bars to be returned for each symbol. Default 100
            - start: Filter bars equal to after this time, ISO Format
            - end: Filter bars equal to or before this time, ISO Format
            - after: Filter bars after this time, ISO Format
            - before: Filter bars before this time, ISO Format
        """

        return self.api.get_barset(symbols, limit, start, end, after, until)


if __name__ == "__main__":
    import alpaca_trade_api as tradeapi

    # Env variables set to initalise connection:
    #   * APCA_API_KEY_ID
    #   * APCA_API_SECRET_KEY
    #   * APCA_API_BASE_URL
    api = TradeApiRest()

    # print(api._get_account_info())

    # Get our account information.
    # account = api._account_info()
    open = api._is_market_open()

    print(open)


#    # Check if our account is restricted from trading.
#     if account.trading_blocked:
#         logger.error('Account is currently restricted from trading.')

#     # Check how much money we can use to open new positions.
#     print('${} is available as buying power.'.format(account.buying_power))
